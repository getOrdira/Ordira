// src/models/collaboration/productionUpdate.model.ts
import { Schema, model, Document, Types, Model } from 'mongoose';

/**
 * Media Attachment Interfaces
 */
export interface IPhotoAttachment {
  url: string;
  s3Key: string;
  caption?: string;
  uploadedAt: Date;
}

export interface IVideoAttachment {
  url: string;
  s3Key: string;
  caption?: string;
  duration?: number; // seconds
  thumbnail?: string;
  uploadedAt: Date;
}

/**
 * Milestone Information Interface
 */
export interface IMilestoneReached {
  name: string;
  targetDate: Date;
  actualDate: Date;
  variance: number; // days ahead/behind (negative = behind, positive = ahead)
}

/**
 * Delay Information Interface
 */
export interface IDelayInfo {
  reason: string;
  estimatedDelay: number; // days
  newEstimatedDelivery: Date;
  actionPlan?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * Viewer Tracking Interface
 */
export interface IUpdateViewer {
  userId: Types.ObjectId;
  viewedAt: Date;
  userType: 'brand' | 'manufacturer';
}

/**
 * Comment Interface
 */
export interface IUpdateComment {
  userId: Types.ObjectId;
  userType: 'brand' | 'manufacturer';
  message: string;
  createdAt: Date;
}

/**
 * Production Update Document Interface
 * Represents real-time status updates from manufacturers to brands
 */
export interface IProductionUpdate extends Document {
  // Relationships
  workspaceId: Types.ObjectId; // Reference to Workspace
  manufacturerId: Types.ObjectId; // Reference to Manufacturer
  createdBy: Types.ObjectId; // User who created the update

  // Update Content
  title: string;
  message: string;
  updateType: 'status' | 'milestone' | 'delay' | 'quality' | 'general';

  // Status Information
  currentStatus?: string; // e.g., 'cutting', 'assembly', 'quality_check'
  completionPercentage?: number; // 0-100

  // Milestone Tracking
  milestoneReached?: IMilestoneReached;

  // Delay/Issue Reporting
  delayInfo?: IDelayInfo;

  // Media Attachments
  photos: IPhotoAttachment[];
  videos: IVideoAttachment[];

  // Engagement
  viewedBy: IUpdateViewer[];
  comments: IUpdateComment[];

  // Notifications
  notificationSent: boolean;
  notificationSentAt?: Date;
  recipientIds: Types.ObjectId[]; // Brand members to notify

  // Automation
  isAutomated: boolean; // true if generated by system
  automationSource?: string; // e.g., 'supply_chain_event', 'milestone_trigger'

  // Metadata
  createdAt: Date;
  updatedAt: Date;

  // Instance methods
  isViewedBy(userId: string): boolean;
  addView(userId: string, userType: 'brand' | 'manufacturer'): Promise<IProductionUpdate>;
  addComment(userId: string, userType: 'brand' | 'manufacturer', message: string): Promise<IProductionUpdate>;
}

/**
 * Production Update Static Methods Interface
 */
export interface IProductionUpdateModel extends Model<IProductionUpdate> {
  findByWorkspace(workspaceId: string, limit?: number): Promise<IProductionUpdate[]>;
  findUnviewedByUser(userId: string): Promise<IProductionUpdate[]>;
  getUpdateStats(workspaceId: string): Promise<any>;
  markAsViewed(updateId: string, userId: string, userType: 'brand' | 'manufacturer'): Promise<void>;
}

/**
 * Photo Attachment Schema
 */
const PhotoAttachmentSchema = new Schema<IPhotoAttachment>({
  url: {
    type: String,
    required: true
  },
  s3Key: {
    type: String,
    required: true
  },
  caption: {
    type: String,
    maxlength: 500
  },
  uploadedAt: {
    type: Date,
    required: true,
    default: Date.now
  }
}, { _id: false });

/**
 * Video Attachment Schema
 */
const VideoAttachmentSchema = new Schema<IVideoAttachment>({
  url: {
    type: String,
    required: true
  },
  s3Key: {
    type: String,
    required: true
  },
  caption: {
    type: String,
    maxlength: 500
  },
  duration: {
    type: Number,
    min: 0
  },
  thumbnail: {
    type: String
  },
  uploadedAt: {
    type: Date,
    required: true,
    default: Date.now
  }
}, { _id: false });

/**
 * Milestone Reached Schema
 */
const MilestoneReachedSchema = new Schema<IMilestoneReached>({
  name: {
    type: String,
    required: true,
    maxlength: 200
  },
  targetDate: {
    type: Date,
    required: true
  },
  actualDate: {
    type: Date,
    required: true
  },
  variance: {
    type: Number,
    required: true
  }
}, { _id: false });

/**
 * Delay Info Schema
 */
const DelayInfoSchema = new Schema<IDelayInfo>({
  reason: {
    type: String,
    required: true,
    maxlength: 1000
  },
  estimatedDelay: {
    type: Number,
    required: true,
    min: 0
  },
  newEstimatedDelivery: {
    type: Date,
    required: true
  },
  actionPlan: {
    type: String,
    maxlength: 2000
  },
  severity: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    required: true,
    default: 'medium'
  }
}, { _id: false });

/**
 * Update Viewer Schema
 */
const UpdateViewerSchema = new Schema<IUpdateViewer>({
  userId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'User'
  },
  viewedAt: {
    type: Date,
    required: true,
    default: Date.now
  },
  userType: {
    type: String,
    enum: ['brand', 'manufacturer'],
    required: true
  }
}, { _id: false });

/**
 * Update Comment Schema
 */
const UpdateCommentSchema = new Schema<IUpdateComment>({
  userId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'User'
  },
  userType: {
    type: String,
    enum: ['brand', 'manufacturer'],
    required: true
  },
  message: {
    type: String,
    required: true,
    maxlength: 2000
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now
  }
}, { _id: true }); // Keep _id for comments to allow deletion

/**
 * Main Production Update Schema
 */
const ProductionUpdateSchema = new Schema<IProductionUpdate>(
  {
    // Relationships
    workspaceId: {
      type: Schema.Types.ObjectId,
      required: [true, 'Workspace ID is required'],
      ref: 'Workspace',
      index: true
    },
    manufacturerId: {
      type: Schema.Types.ObjectId,
      required: [true, 'Manufacturer ID is required'],
      ref: 'Manufacturer',
      index: true
    },
    createdBy: {
      type: Schema.Types.ObjectId,
      required: [true, 'Creator ID is required'],
      ref: 'User'
    },

    // Update Content
    title: {
      type: String,
      required: [true, 'Update title is required'],
      trim: true,
      maxlength: [200, 'Title cannot exceed 200 characters']
    },
    message: {
      type: String,
      required: [true, 'Update message is required'],
      trim: true,
      maxlength: [5000, 'Message cannot exceed 5000 characters']
    },
    updateType: {
      type: String,
      enum: {
        values: ['status', 'milestone', 'delay', 'quality', 'general'],
        message: 'Update type must be status, milestone, delay, quality, or general'
      },
      required: [true, 'Update type is required'],
      index: true
    },

    // Status Information
    currentStatus: {
      type: String,
      trim: true,
      maxlength: 100
    },
    completionPercentage: {
      type: Number,
      min: 0,
      max: 100
    },

    // Milestone Tracking
    milestoneReached: {
      type: MilestoneReachedSchema,
      default: undefined
    },

    // Delay/Issue Reporting
    delayInfo: {
      type: DelayInfoSchema,
      default: undefined
    },

    // Media Attachments
    photos: {
      type: [PhotoAttachmentSchema],
      default: []
    },
    videos: {
      type: [VideoAttachmentSchema],
      default: []
    },

    // Engagement
    viewedBy: {
      type: [UpdateViewerSchema],
      default: []
    },
    comments: {
      type: [UpdateCommentSchema],
      default: []
    },

    // Notifications
    notificationSent: {
      type: Boolean,
      required: true,
      default: false
    },
    notificationSentAt: {
      type: Date
    },
    recipientIds: {
      type: [Schema.Types.ObjectId],
      default: [],
      ref: 'User'
    },

    // Automation
    isAutomated: {
      type: Boolean,
      required: true,
      default: false
    },
    automationSource: {
      type: String,
      trim: true,
      maxlength: 100
    }
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: function(doc, ret) {
        delete ret.__v;
        return ret;
      }
    },
    toObject: { virtuals: true }
  }
);

// ====================
// INDEXES FOR MONGODB ATLAS PERFORMANCE
// ====================

// Composite index for workspace timeline queries
ProductionUpdateSchema.index({ workspaceId: 1, createdAt: -1 });

// Index for manufacturer's updates
ProductionUpdateSchema.index({ manufacturerId: 1, createdAt: -1 });

// Index for filtering by update type
ProductionUpdateSchema.index({ updateType: 1, createdAt: -1 });

// Index for finding updates viewed by a user
ProductionUpdateSchema.index({ 'viewedBy.userId': 1 });

// Index for notification processing
ProductionUpdateSchema.index({ notificationSent: 1, createdAt: -1 });

// Index for automated updates
ProductionUpdateSchema.index({ isAutomated: 1, automationSource: 1 });

// Compound index for delay alerts
ProductionUpdateSchema.index({
  updateType: 1,
  'delayInfo.severity': 1,
  createdAt: -1
}, { sparse: true });

// ====================
// VIRTUAL PROPERTIES
// ====================

// Virtual for total engagement count
ProductionUpdateSchema.virtual('engagementCount').get(function() {
  return this.viewedBy.length + this.comments.length;
});

// Virtual for media count
ProductionUpdateSchema.virtual('mediaCount').get(function() {
  return this.photos.length + this.videos.length;
});

// Virtual for view count
ProductionUpdateSchema.virtual('viewCount').get(function() {
  return this.viewedBy.length;
});

// Virtual for comment count
ProductionUpdateSchema.virtual('commentCount').get(function() {
  return this.comments.length;
});

// ====================
// INSTANCE METHODS
// ====================

// Check if update has been viewed by a user
ProductionUpdateSchema.methods.isViewedBy = function(userId: string): boolean {
  const userIdStr = userId.toString();
  return this.viewedBy.some(
    (viewer: IUpdateViewer) => viewer.userId.toString() === userIdStr
  );
};

// Add a view record
ProductionUpdateSchema.methods.addView = function(
  userId: string,
  userType: 'brand' | 'manufacturer'
): Promise<IProductionUpdate> {
  if (!this.isViewedBy(userId)) {
    this.viewedBy.push({
      userId: new Types.ObjectId(userId),
      viewedAt: new Date(),
      userType
    });
    return this.save();
  }
  return Promise.resolve(this);
};

// Add a comment
ProductionUpdateSchema.methods.addComment = function(
  userId: string,
  userType: 'brand' | 'manufacturer',
  message: string
): Promise<IProductionUpdate> {
  this.comments.push({
    userId: new Types.ObjectId(userId),
    userType,
    message,
    createdAt: new Date()
  } as IUpdateComment);
  return this.save();
};

// ====================
// STATIC METHODS
// ====================

// Find updates for a workspace
ProductionUpdateSchema.statics.findByWorkspace = function(
  workspaceId: string,
  limit: number = 20
) {
  return this.find({ workspaceId })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate('createdBy', 'name email');
};

// Find unviewed updates for a user
ProductionUpdateSchema.statics.findUnviewedByUser = function(userId: string) {
  return this.find({
    'viewedBy.userId': { $ne: userId },
    recipientIds: userId
  })
    .sort({ createdAt: -1 })
    .populate('workspaceId', 'name workspaceId');
};

// Get update statistics for a workspace
ProductionUpdateSchema.statics.getUpdateStats = async function(workspaceId: string) {
  const stats = await this.aggregate([
    { $match: { workspaceId: new Types.ObjectId(workspaceId) } },
    {
      $group: {
        _id: '$updateType',
        count: { $sum: 1 },
        avgViewCount: { $avg: { $size: '$viewedBy' } },
        avgCommentCount: { $avg: { $size: '$comments' } },
        totalPhotos: { $sum: { $size: '$photos' } },
        totalVideos: { $sum: { $size: '$videos' } }
      }
    }
  ]);

  return stats;
};

// Mark update as viewed by user
ProductionUpdateSchema.statics.markAsViewed = async function(
  updateId: string,
  userId: string,
  userType: 'brand' | 'manufacturer'
) {
  await this.findByIdAndUpdate(
    updateId,
    {
      $addToSet: {
        viewedBy: {
          userId: new Types.ObjectId(userId),
          viewedAt: new Date(),
          userType
        }
      }
    }
  );
};

// ====================
// MIDDLEWARE
// ====================

// Pre-save: Calculate variance for milestones
ProductionUpdateSchema.pre('save', function(next) {
  if (this.milestoneReached && this.isModified('milestoneReached')) {
    const target = this.milestoneReached.targetDate.getTime();
    const actual = this.milestoneReached.actualDate.getTime();
    const diffDays = Math.round((actual - target) / (1000 * 60 * 60 * 24));
    this.milestoneReached.variance = diffDays;
  }
  next();
});

// Pre-save: Validate delay info
ProductionUpdateSchema.pre('save', function(next) {
  if (this.updateType === 'delay' && !this.delayInfo) {
    return next(new Error('Delay info required for delay update type'));
  }
  next();
});

export const ProductionUpdate = model<IProductionUpdate, IProductionUpdateModel>(
  'ProductionUpdate',
  ProductionUpdateSchema
);
